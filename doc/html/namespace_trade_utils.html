<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Hearthstone Simulator: TradeUtils Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">Hearthstone Simulator 0.1</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TradeUtils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Aggregates utility functions and types, forming a small framework for computing (an approximation of) the best trade a player could make at a given moment.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable of this type is a simple representation of a minion.  <a href="struct_trade_utils_1_1_h_p___a_t_k.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a561aaea533383d077cb8e9e37eac3de8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_trade_utils.html#a561aaea533383d077cb8e9e37eac3de8">bestTrade</a> (<a class="el" href="class_player.html">Player</a> *atker, <a class="el" href="class_player.html">Player</a> *target, bool ignoreHasAttacked)</td></tr>
<tr class="memdesc:a561aaea533383d077cb8e9e37eac3de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes heuristically the value of a very good possible trade.  <a href="#a561aaea533383d077cb8e9e37eac3de8">More...</a><br /></td></tr>
<tr class="separator:a561aaea533383d077cb8e9e37eac3de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecbc972678637688da23d08ecace4a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_trade_utils.html#abecbc972678637688da23d08ecace4a0">removeItem</a> (QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *map, int key, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> *item)</td></tr>
<tr class="memdesc:abecbc972678637688da23d08ecace4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeItem Remove and destroy (i.e., call delete) the item <em>item</em> (which has key <em>key</em>) from list <em>map</em>.  <a href="#abecbc972678637688da23d08ecace4a0">More...</a><br /></td></tr>
<tr class="separator:abecbc972678637688da23d08ecace4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8faf49abb2f82f7095a4b3e77ee95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_trade_utils.html#a6fb8faf49abb2f82f7095a4b3e77ee95">updateItemPosition</a> (QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *map, int key, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> *item)</td></tr>
<tr class="memdesc:a6fb8faf49abb2f82f7095a4b3e77ee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateItemPosition Refresh <em>item</em> key in <em>map</em> so that <em>map</em> stays ordered when <em>item</em> hp and atk fields have been updated somewhere.  <a href="#a6fb8faf49abb2f82f7095a4b3e77ee95">More...</a><br /></td></tr>
<tr class="separator:a6fb8faf49abb2f82f7095a4b3e77ee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bae3227486ca32d8b8a4382a67a2b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_trade_utils.html#a0bae3227486ca32d8b8a4382a67a2b18">tauntablesToStructs</a> (const QVector&lt; <a class="el" href="class_minion.html">Minion</a> * &gt; *minions, QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; **atkables, QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; **others)</td></tr>
<tr class="memdesc:a0bae3227486ca32d8b8a4382a67a2b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a list of minions into lists of minions representations, regarding the absence or presence of some TAUNT minions.  <a href="#a0bae3227486ca32d8b8a4382a67a2b18">More...</a><br /></td></tr>
<tr class="separator:a0bae3227486ca32d8b8a4382a67a2b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eccbd9f95fecb2e0b2f79a909d2f7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_trade_utils.html#a1eccbd9f95fecb2e0b2f79a909d2f7ce">minionsToStructs</a> (const QVector&lt; <a class="el" href="class_minion.html">Minion</a> * &gt; *minions, QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *structs)</td></tr>
<tr class="memdesc:a1eccbd9f95fecb2e0b2f79a909d2f7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a list of minions into a list of minion representations, regardless that they have TAUNT or not.  <a href="#a1eccbd9f95fecb2e0b2f79a909d2f7ce">More...</a><br /></td></tr>
<tr class="separator:a1eccbd9f95fecb2e0b2f79a909d2f7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregates utility functions and types, forming a small framework for computing (an approximation of) the best trade a player could make at a given moment. </p>
<p>A <em>trade</em> is the result of an attack of an allied minion onto enemy minions. If one can use an ally minion to kill N enemy minions, we say this is a <em>N for 1 trade</em>. One usually wants to maximize N.</p>
<p>A trade may also denotes the result of a single attack, and here we mainly use this definition.</p>
<p>Trading a 4ATK/1HP ally minion against a 1ATK/1HP enemy minion is not a good trade for us, but it is a good one for the enemy player: trades values are symmetrical and whether it is good or bad depends on which side you are. For this last example, if the 4/1 minion belongs to you, the trade would have a value of -3 for you (you gained 2 points because you killed the enemy 1/1 minion and 1 + 1 = 2, but you lost 5 points because this killing was made at the expense of loosing your 4/1 minion while 4 + 1 = 5; therefore the trade value is 2 - 5 = -3). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a561aaea533383d077cb8e9e37eac3de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TradeUtils::bestTrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>atker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreHasAttacked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes heuristically the value of a very good possible trade. </p>
<p>Computes the value of <em>an approximation of<em> the best trade player <em>atker</em> can make against player <em>target</em>. The <em>ignoreHasAttacked</em> parameter specifies whether or not the computation should also take into account allied minions for which the game considers they already attacked (see Character::hasAttacked()).</em></em></p>
<p><em><em></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atker</td><td>The player considered as in its attack phase </td></tr>
    <tr><td class="paramname">target</td><td>The other player </td></tr>
    <tr><td class="paramname">ignoreHasAttacked</td><td>specifies whether or not the computation should also take into account allied minions for which the game considers they already attacked (see Character::hasAttacked())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the trade approximated and considered as the best one. </dd></dl>
<p></em></em></p>

</div>
</div>
<a class="anchor" id="a1eccbd9f95fecb2e0b2f79a909d2f7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TradeUtils::minionsToStructs </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="class_minion.html">Minion</a> * &gt; *&#160;</td>
          <td class="paramname"><em>minions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *&#160;</td>
          <td class="paramname"><em>structs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a list of minions into a list of minion representations, regardless that they have TAUNT or not. </p>
<p>This function is used to get a light list of minions that can be modified without modifying the game data and preventing side effects. The resulting format of such light minions is just their current HP and ATK (see <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html" title="A variable of this type is a simple representation of a minion. ">HP_ATK</a> type). This list translates the whole <em>minions</em> list, regardless of whether some minions have TAUNT or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minions</td><td>The original list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">structs</td><td>A pointer to the list to fill with the translation. The key for a given <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html" title="A variable of this type is a simple representation of a minion. ">HP_ATK</a> structure is the sum of its <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#acd4c707f3070a8a442850a86a07315cd" title="The remaining HP of the represented minion. ">HP_ATK::hp</a> and <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#a3d164320ea2d8bd90bd89dcbf8f454f7" title="The current ATK of the represented minion. ">HP_ATK::atk</a> fields, ensuring <em>structs</em> is ordered by minion power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abecbc972678637688da23d08ecace4a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TradeUtils::removeItem </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeItem Remove and destroy (i.e., call delete) the item <em>item</em> (which has key <em>key</em>) from list <em>map</em>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior (likely to crash) if <em>item</em> with key  is not found in  !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The list from which to remove <em>item</em> </td></tr>
    <tr><td class="paramname">key</td><td>The key with which <em>item</em> was put in <em>map</em> initially </td></tr>
    <tr><td class="paramname">item</td><td>The item to remove (Some items in the list could have the same key, thus the item has to be passed in argument too to be able to remove this very <em>item</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bae3227486ca32d8b8a4382a67a2b18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TradeUtils::tauntablesToStructs </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="class_minion.html">Minion</a> * &gt; *&#160;</td>
          <td class="paramname"><em>minions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; **&#160;</td>
          <td class="paramname"><em>atkables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; **&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a list of minions into lists of minions representations, regarding the absence or presence of some TAUNT minions. </p>
<p>This function is used to get light lists of minions that can be modified without modifying the game data and preventing side effects. The resulting format of such light minions is just their current HP and ATK (see <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html" title="A variable of this type is a simple representation of a minion. ">HP_ATK</a> type).</p>
<p>If one wants to separate attackable minions from others (in the case some have TAUNT), this function can come in handy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minions</td><td>The original list </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">atkables</td><td><code>*</code> <em>atkables</em> will be allocated in this function and will contain the list of attackable minions found in <em>minions</em>. The key for a given <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html" title="A variable of this type is a simple representation of a minion. ">HP_ATK</a> structure is the sum of its <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#acd4c707f3070a8a442850a86a07315cd" title="The remaining HP of the represented minion. ">HP_ATK::hp</a> and <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#a3d164320ea2d8bd90bd89dcbf8f454f7" title="The current ATK of the represented minion. ">HP_ATK::atk</a> fields, ensuring <em>structs</em> is ordered by minion power. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">others</td><td>If there are TAUNT minions in <em>minions</em>, <code>*</code> <em>others</em> will be allocated in this function and will contain the list of minions from <em>minions</em> which do not have TAUNT. If <em>minions</em> does not contain any TAUNT, <code>*</code> <em>others</em> will be set to <code>NULL</code>. The key for a given <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html" title="A variable of this type is a simple representation of a minion. ">HP_ATK</a> structure is the sum of its <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#acd4c707f3070a8a442850a86a07315cd" title="The remaining HP of the represented minion. ">HP_ATK::hp</a> and <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html#a3d164320ea2d8bd90bd89dcbf8f454f7" title="The current ATK of the represented minion. ">HP_ATK::atk</a> fields, ensuring <em>structs</em> is ordered by minion power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fb8faf49abb2f82f7095a4b3e77ee95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TradeUtils::updateItemPosition </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; int, <a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> * &gt; *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_trade_utils_1_1_h_p___a_t_k.html">HP_ATK</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updateItemPosition Refresh <em>item</em> key in <em>map</em> so that <em>map</em> stays ordered when <em>item</em> hp and atk fields have been updated somewhere. </p>
<dl class="section warning"><dt>Warning</dt><dd>Undefined behavior (likely to crash) if <em>item</em> with key  is not found in  !</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The list containing the item whose position has to be updated </td></tr>
    <tr><td class="paramname">key</td><td>The key <em>item</em> was put with initially in <em>map</em> </td></tr>
    <tr><td class="paramname">item</td><td>The item whose position in <em>map</em> should be updated (Some items in the list could have the same key, thus the item has to be passed in argument too to be able to remove this very <em>item</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 31 2015 11:49:21 for Hearthstone Simulator by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
